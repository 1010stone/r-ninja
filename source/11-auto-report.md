# 自动化报告

人类和计算机有各自擅长的东西，人擅长下指令，计算机擅长执行指令，而且对计算机来说，一个任务做一遍或是做一百遍可能只有时间上的区别，但一个人要是同一个任务重复做一百遍可能就抓狂了，而且容易出错。先跑个题，我想起来有个[短片](http://v.youku.com/v_show/id_XMjQyNjU3NjA0.html)叫《What is that》（那是什么），讲的是一对父子和一只麻雀的故事，网上一[搜](http://www.dfg.cn/gb/jtjy/qzp/56-ai.htm)就可以找到；当然，它的主题并不是关于人不能忍受重复劳动，我只是跑题而已。

另一方面，人还有最大的一个特征就是懒惰；懒没什么错，看怎么个懒法。有人纯粹是混日子的懒，有人是为了更高效率工作而走捷径。用R做自动化报告就是为了提高效率和保证结果可重复。

## 历史

在R的世界里，凡是提到自动化报告，很多人就会想到Sweave，它已经诞生十几年了。它的主要设计思想来自于文学化编程（Literate Programming），这是Knuth大神提出来的一种编程范式，它与传统的结构化编程不同。结构化编程就是写那些循环（for/while）、选择分支（if else）、函数模块之类的代码，让计算机去按设定好的程序结构去执行，而文学化编程则是把代码嵌入所谓的文学作品中，之所以说所谓的，是因为这里的文学不一定真的是那种常规意义下的文学，只是指人类语言而已，相对计算机代码而言。文学化编程的思想很简单：代码和正文混和在同一个文档中，编译的时候既可以把代码抽出来运行得到结果，也可以把正文抽出来形成软件文档。最初它是为了写软件而设计的，这种设计方式的优势显而易见：代码和文档在一起，方便互相更新和照应。比如修改了代码之后可以很快也更新相应的文档段落，而不必像传统方式那样，从源代码文件跳到文档文件中去更新（人的记忆不可靠，这事儿经常忘记，造成代码和文档不一致）。

要使用文学化编程，必须得有一些设定的规则来标记哪些是代码，哪些是正文，否则这事儿没法进行。最早的语法是这样：用`<<>>=`来标记代码的开始，用`@`标记正文的开始，凡是遇到这两类符号，也就意味着要换频道了，下文要标记为代码或正文。例如，

```
@
hello, I will do 1 + 2 next:

<<foo>>=
1 + 2
@

OK, I'm done now.
```

这一块文字中包含两段正文和一段代码。编译它的时候，计算机根据前面的规则就知道`<<>>=`下面的是可以运算的代码，而`@`下面是正文，不能当作代码运行。这就是文学化编程的基本思想，它可以很容易移植到自动化报告中来，下面我们再详细说里面的细节问题。Sweave借用了这个思想，把R代码嵌入报告中，编译报告的时候R代码被执行，源文档中的R代码在输出的时候被替换为相应的运行结果，这些结果和原来的报告正文混合起来就形成了一篇有结果的报告。这样，我们只需要维护包含源代码的源文档，让结果文档自动生成，而不要手工运行代码并复制粘贴结果到文档里，这样做既累人又容易出错。记住，只有源代码是可以信赖的。注意我并不是说它的结果一定是对的，或者源代码一定是对的，代码当然可能是错的，但源代码要是错了我们可以检查出来，而要是人工操作哪里出了岔子就很难查错，比如你本来应该点这个按钮，结果你当时点了另一个，如果没有完整的屏幕录像，恐怕追溯结果的来源时就比较困难了。源代码通常是文本文件，可以放入版本控制如GIT或SVN，记录完整的修改历史。附带说一句，版本控制（Version Control）工具是忍者必备工具，后面会用专门用一章讲，你要是不会这东西的话，别跟别人说你看过这本书。

文学化编程最早和TeX结合在一起，因为文档用TeX写漂亮嘛，但这事儿跟Knuth肯定也脱不了关系，因为这位大神就是TeX系统的作者，这是计算机世界的佳话（老人家当年不满意出版社的排版质量，一举自己写了一套高质量排版系统，并写支票奖励发现缺陷的人，奖金都是16进制的1美元，而且金额随缺陷数目递增，我跑远了，各位要是没听说过这些轶事自己搜吧）。于是，计算机代码用某种语言写，比如C语言，而文档用TeX写；要源代码可以抽代码，要文档可以抽文档，皆大欢喜。

Sweave的诞生也跟TeX绑在一起，这就为它后来的应用埋下了悲剧的种子，因为TeX不是一般人能精通的。我用了八年LaTeX，自认为对它还比较熟，但仅限于使用，要是让我去读那些LaTeX包的源代码，我几乎读不懂，太庞大太复杂了。Sweave的设计里处处是硬编码，所以它很难扩展，一直以来只能被框在TeX世界里，曲高和寡。尽管Knuth大人弄出来这样一个牛轰轰的想法，Sweave基本上也把它实现了，但这东西太难推广了。初学者编译TeX文档难免遇到一堆看不懂的错误，进而气馁，最后疏远它。我用了几年Sweave，在这方面也做了很多工作，想让它变得易用一些，比如开发了LyX模块，让用户可以在LyX里面点按钮就可以直接编译得到PDF文件。即便如此，Sweave的深层问题无法解决，很多简单的问题我等了又等（比如设置图片在TeX文档中的宽度），一直没有等到答案，屡屡想重写它，但忍者的基本素质就是忍，没事儿不要重新发明一个东西。2011年底我终于忍不住了，操起键盘重写了一个新包，叫**knitr**。

因为这里是谈历史，不妨写一个小插曲：**knitr**这个包的名字是怎么来的呢？Sweave实际上是由S（代表S语言，也就是R语言它娘亲）和weave（编织）组成的，Weave是文学化编程的概念，就是把文字和代码编织到一起。我在考虑包的名字的时候，由于满心要对Sweave的各种不利索吐槽，所以我决定给我的新包一个利索的名字，英语里说利索通常用neat这个词，而同时编织还有另一个词叫knit，二者发音相近，用它取名可谓一石二鸟。knit后面加上字母r也有几重考虑：

- R代表R语言，为什么小写？因为小写对用户来说输入方便，不用按Shift
- knitr看起来和读起来像knitter，谐音neater，充分表达了某种要凌驾于对手之上的情绪，说得不好听就是自恋
- knitr不是一个正常的英文单词，所以Google搜索的第一条确定一定以及肯定会是我的网站，方便用户搜到文档，在各种社交网络上它也可以作为标签，比如`#knitr`（微博、Twitter）

这就是一个包名背后的各种阴险考虑。当一名忍者不容易啊，你得周密布置陷阱，让别人乖乖掉进你的坑。

## knitr包

你要是没学习过Sweave，最好别去花那时间，可以直接跳入**knitr**世界，它兼容Sweave并提供了无限的扩展性，这本书就是用它基于Markdown写的。先举一个hello world例子吧：

``` {r knitr-hello}
1 + 2
dnorm(0) # 标准正态分布在0处的密度值
summary(lm(dist ~ speed, data=cars)) # 一个回归
````

上面你看到的是R的输出，其实它的源文件只有5行，1行标记代码开始，3行R代码，1行标记正文开始，如下所示：

`````
    ``` {r knitr-hello}
    1 + 2
    dnorm(0) # 标准正态分布在0处的密度值
    summary(lm(dist ~ speed, data=cars)) # 一个回归
    ````
`````

我们用**knitr**编译这段代码，就得到了上面的输出。现在，你应该对自动化报告有一个初步了解了。**Knitr**的网站（<http://yihui.name/knitr>）中有详尽的英文文档和示例，英文方面没有障碍的忍者可以随时查阅。为了新忍入门更快，我在这里把整个故事的梗概叙述一遍。

### 语法

为了**knitr**能识别文档中的R代码，我们必须对代码文本有特殊标记，前面说的`<<>>=`就是一种可能的标记。同时，我们还可以设置一些运行代码的选项，这些软件方面的选项不应该是正文的一部分，所以也要用特殊标记保护起来。所有这些标记的规定，就是我们要谈的语法。对**knitr**而言，不同格式的文档有不同语法。

LaTeX文档（扩展名`Rnw`）里面仍然沿用历史规定，代码放在`<<>>=`之下，注意`<<`要在一行顶头，前面不能有空格或任何其它字符；在`<<`与`>>`之间我们可以对下面的代码设置一些运行选项，例如`<<foo, echo=TRUE, eval=TRUE>>=`，其中第一个选项没有取值，它是这段代码的标签，这个选项是代码段的唯一标识符，所以不同代码段必须用不同的标签，它主要被用来写图片文件名（如果下面的代码会生成图片的话）以及缓存文件名，如果标签为空，那么**knitr**会自动生成形如`unnamed-chunk-1`、`unnamed-chunk-2`之类的标签；所有自带选项参见<http://yihui.name/knitr/options>，选项列表很长，因为可以控制的细节非常多。`@`字符用来标记下面要开始正文了，它同样需要出现在一行的顶头，后面可选择性跟着LaTeX注释（以`%`开头）。在`<<>>=`里面设置的代码段选项是局部选项，仅仅对当前代码段有效；我们也可以设置全局选项，语法为`\SweaveOpts{opt=value}`，它可以出现在正文的任意位置（通常在开头），从这句话出现开始，后面的代码段都会默认使用这里设置的选项，但注意局部选项优先于全局选项。除了代码段中可以放R代码之外，还有另一种形式的R代码称为行内代码，顾名思义，它是嵌在正文段落文字内的代码，通常比较简短，用来输出单个值，语法为`\Sexpr{x}`，其中`x`代表当前环境下的变量`x`，这个标记会被运行并返回值嵌入原来的文本，它也是一个有用的应用，例如我们可以在正文里写“回归结果的斜率为`\Sexpr{coef(fit)[2]}`”，当我们在前面建了一个回归模型之后（假定名为`fit`），这句话编译之后就会变成含有真实数字的文字，如“回归结果的斜率为`0.314`”。回顾一下，以上提到几个重要概念：

- 代码段，就是独立段落的R代码，每段代码必须有唯一的标签
- 行内代码，嵌入文字的小代码
- 局部选项，在代码段上方的`<<>>=`标记里设置
- 全局选项，在`\SweaveOpts{}`里设置

选项让我们可以非常灵活地控制代码的输出，例如如果我们想隐藏R代码，只显示运行结果（你给老板交报告的时候当然不能连R代码也显示，除非老板也是代码控），那么我们可以用`echo`选项，设置`echo=FALSE`就可以隐藏R代码；如果我们想让输出图形的宽度为5英寸，则可以设置`fig.width=5`，等等。

由于LaTeX文档入门门槛高，而网页则相对容易一些，**knitr**在设计之初就考虑了网页格式，它有两种可能：一是原始HTML格式，即把R代码嵌入HTML代码；二是Markdown（下文简称MD），它是非常轻量级的标记语言，可以很方便翻译为HTML语言。我一般倾向于用后者。MD的出现是为了简化HTML，把常用的HTML标签用极度简化的语法写出来，这一点值得程序设计者学习：你可以写一个无所不能但繁琐的程序，也可以写能实现常用功能但简单的程序。R就有前者的特征，尤其是很多函数有长串的参数，看着就让人发蒙，而实际上只有少数参数是常用的，当然，这一点上不必吐槽，因为R是一门基础语言，功能优先。这是题外话。

HTML文档混合R代码的语法为：以`<!--begin.rcode label, opt=value`开始R代码，以`end.rcode-->`开始正文。全局选项放在`<!--roptions -->`中，行内代码放在`<!--rinline -->`中。熟悉HTML语法的都知道，`<!-- -->`是HTML注释的语法。我对Sweave语法不太满意的一点也在此：文学化编程的文档最好能避免破坏原文档的语法，比如要是我来设计Sweave，我肯定不会用`<<>>=`语法，因为它干扰了TeX文档，我会倾向于把R代码段放在TeX注释中，这样即使不编译，这份文档也是合法的TeX文档。

MD文档语法为：以三个反引号和一对大括号开始R代码，以四个反引号开始正文。

### 文本输出

### 图形控制

### 缓存

## 编辑器

### LyX

### RStudio

## 其它包

